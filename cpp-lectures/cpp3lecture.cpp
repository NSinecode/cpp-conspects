#include <iostream>

/*
1 min тернарный оператор
4 min оператор запятая
12 min порядок операций
15 min код
22 min циклы
35 min эксперименты с фор
40 min ошибки компиляции
55 min Runtime error
1 hour 1 min - UB
*/

int main()
{
    /*
    ternary operator
    a: b:c
    если хоть один компонент тарнарника r-value - весь тернарник r-value
    */

    /*
    , operator
    int a, b; сначала вычисляет а, gjnjv и
    , самый низкий приоритет
    :: самый высокий приортиет

    f(a,b) тут запятая не тот же самый оператор
    */
   // std::cout << a++, b, f(a,b);
   // (cout << a++), (b), (f(a,b)); вот так будут расставлены приоритеты

   /*
   Офф топ: что такое оператор?
   оператор позволяет взаимодействовать в элементами
   бывает унарным и бинарным (взаимодействие с одним и двумя соответственно)

   , позволяет разделять l, r
   a++,в++ гарантируется что что сначала увеличится а потом увеличится в.
   */
  // int a,b,c;
  // a++,b++,c++;

  /*
  f() + g() * h();
  Определен порядок вычисления, но проядок вызова функции не определен. 
  Поэтому то что будет принтится (если функции будут выводить в поток вывода) не определено.
  */

  // 1.5 Control statement

  // if-else
  if (true) {
    
  } else {

  }
  int a = 5;
  switch(a) //Принимает int char enum(перечисление пронумерованных сущностей)
  {
    case 1:
      a++;
      break;
    case 2:
      a--;
      break; // Если не написать брейк мы будем и дальше гулять по кейсам
    default: // Переходим сюда если не попали ни в один заданный кейс
      a++;
  }

  while (a-- > 0) {

  }

  do {

  } while (a++ <5);

  // В чем разница? вайл сначала проверяет условие потом 

  for (int a = 5, b = 0; a < 10; a++);
  //for (declaration/expression; условие которое проверяем каждый раз перед заходом; делаем после цикла)

  /*
  в форе можно написать тернарник, но не иф елз
  */
  for (int i = 0; i < 5; i % 2 == 0 ? i--:i++)
    std::cout << i << "\n";
  
  // for (int i = 0; i < 5; if (true) i++; else i--;) так нельзя поскольку ветвление это не экспрешн, а тернарник да.
  // declaration не имеет смысла пихать в третью часть фора))
  // range based hor and for each -- ресерчнуть

  // 1.6 CE, RE, UB - compile error, runtime error, undefined behaivor
  /*
  есть несколько вариантов разобрать текст
  */
  /*
   elsee - лексическая ошибка. Лексема это минимальная частичка которую компилятор может распарсить. (токен и лексема - одно и то же)

   std::cout << a +; - лексическая ошибка. + это бинарный оператор, а компилятор не видит второй переменной
   мы написали все лексемы верно, но компилятор не понимает как сложить а и ;

   семантическая ошибка самая высокоуровневая
   std::cout << s.push_back(12); оператор вывода в поток не может принять void.
   "стол съешь ручей" - слова написанны верно, синтаксис тоже, но стол не может съесть ручей, у него нет такой функции, стол это стол.
  */

  /*
  Разница между семантикой и синтаксисом:
  */
  namespase N
  {
    int x;
  }
  int x;

  using namespase N;
  x++;
  //Программа корректна, но программа не понимает какой х выбарть.
  //Смысловая ошибка. (фиксится N::x)

  /*Runtime errors
  5/0; Когда программа запускается, мы получаем ошибку во время работы программы
  
  std::vector<int> a(7);
  a[1000000000] если сильно выходим а границы и пытаемся воспользовались не принадлежащей нам памятью
  */

  /*
  Undefined behavoir
  int z;
  std::cout << z; мы не понимаем как будет работать программа. В одном случае работает как ожидаем, в другом случае нет
  переполнение: обычный инт это уб
  ансайнд -- все зациклится
  */

  for (int i = 0; i < 300; i++)
    std::cout << i << " " << i * 123456789 << "\n";
  /* 
  Это классический цикл чтобы увидеть переполнение инта
  флаги оптимизации оптимизируют эдж кейсы и в целом код
  но с флагом оптимизации O2 компилятор предупреждает о таком
  В этом случае (флаг оптимизации) компилятор считает что андефайн бехейвора нет
  Поэтому мы уходим в бесконечный цикл
  при i = 174 мы переполняемся, но компилятор думает что этого не произойдет и убирает проверку
  */
}

